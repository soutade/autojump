#!/usr/bin/env python
#Copyright Gregory Soutade 2010
#Copyright Joel Schaerer 2008-2010
#This file is part of autojump

#autojump is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.
#
#autojump is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License
#along with autojump.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import division, print_function

try: # fix to get optimised pickle in python < 3
    import cPickle as pickle
except ImportError:
    import pickle

import getopt
from sys import argv, exit, stderr, version_info
from tempfile import NamedTemporaryFile
from operator import itemgetter
import os
import signal
from optparse import OptionParser

max_keyweight = 1000
max_stored_paths = 600
completion_separator = '__'
config_dir = os.environ.get("AUTOJUMP_DATA_DIR", os.path.expanduser("~"))

def signal_handler(arg1, arg2):
    print ("Received SIGINT, trying to continue")
signal.signal(signal.SIGINT,signal_handler) #Don't break on sigint

def dicadd(dic, key, increment=1):
    value = dic.get(key, 0.)+increment
    dic[key] = value
    if value > max_keyweight:
        forget(dic) #gradually forget about old directories

def dicremove(dic, key):
    if key not in dic:
        # Try without last character (/ or \)
        if key[:-1] in dic:
            key = key[:-1]
        else:
            return False
    del dic[key]
    return True

def save(path_dict, dic_file):
    f = NamedTemporaryFile(dir=config_dir, delete=False)
    pickle.dump(path_dict, f, -1)
    f.flush()
    os.fsync(f)
    f.close()
    os.rename(f.name, dic_file) #cf. http://thunk.org/tytso/blog/2009/03/15/dont-fear-the-fsync/
    try: #backup file
        import time 
        if not os.path.exists(dic_file+".bak") or time.time() - os.path.getmtime(dic_file+".bak") > 86400:
            import shutil
            shutil.copy(dic_file, dic_file+".bak")
    except OSError as e:
        print ("Error while creating backup autojump file. (%s)" % e, file=stderr)

def forget(path_dict):
    """Gradually forget about directories. Only call from the actual jump since it can take time"""
    for k in path_dict.keys():
        path_dict[k] *= 0.9 * max_keyweight / keyweight

def clean_dict(path_dict):
    """Limits the sized of the path_dict to max_stored_paths. Returns True if keys were deleted"""
    if len(path_dict) > max_stored_paths:
        dirs = list(path_dict.items())
        dirs.sort(key = itemgetter(1), reverse=True)
        #remove 25 more than needed, to avoid doing it every time
        for dir, dummy in dirs[max_stored_paths-25:]:
            del path_dict[dir]
        return True
    else: 
        return False

def find_matches(cur_path, dirs, pattern, result_list, ignore_case, max_matches):
    """Find max_matches paths that match the pattern, and add them to the result_list"""
    for path,count in dirs:
        if len(result_list) >= max_matches : break
        if (cur_path == path) or (path in result_list): continue
        if re.search(pattern, path, ignore_case and re.IGNORECASE):
            result_list.append(path)

def open_dic(dic_file, error_recovery=False):
    try:
        aj_file = open(dic_file, 'rb')
        if version_info[0] > 2:
            #encoding is only specified for python2.x compatibility
            path_dict = pickle.load(aj_file, encoding="utf-8")
        else:
            path_dict = pickle.load(aj_file)
        aj_file.close()
        return path_dict
    except (IOError, EOFError, pickle.UnpicklingError):
        if not error_recovery and os.path.exists(dic_file+".bak"):
            print('Problem with autojump database, trying to recover from backup...', file=stderr)
            import shutil
            shutil.copy(dic_file+".bak", dic_file)
            return open_dic(dic_file, True)
        else: return {} #if everything fails, return an empty file

def stat():
    a = list(path_dict.items())
    a.sort(key=itemgetter(1))
    for path,count in a[-100:]:
        print("%.1f:\t%s" % (count,path), file=stderr)
    print("Total key weight: %d. Number of stored paths: %d" % (sum(path_dict.values()),len(a)), file=stderr)

#################################### Main code ####################################
if __name__ == '__main__':
    usage = '%prog [options]\n'\
            'Easier file system navigation using command line'
    optparser = OptionParser(usage=usage)

    optparser.add_option('-a', '--add', dest='add',
                         help='Add a new path to the database',
                         metavar="path")
    optparser.add_option('-r', '--remove', dest='remove',
                         help='Remove a path from the database',
                         metavar="path")
    optparser.add_option('-p', '--purge', dest='purge',
                         help='Purge the database for each key <= num',
                         metavar="num")
    optparser.add_option('-i', '--import', dest='imp',
                         help='Import a database',
                         metavar="database")
    optparser.add_option('-s', '--stat', dest='stat',
                         action="store_true",
                         help='Show statistics')
    optparser.add_option('-c', '--completion', dest='completion',
                         action="store_true",
                         help='Use autojump\'scompletion')
    optparser.add_option('-b', '--bash', dest='bash',
                         action="store_true",
                         help='Current shell is bash')

    (optlist, args) = optparser.parse_args(argv[1:])

    if config_dir == os.path.expanduser("~"):
        dic_file = config_dir+"/.autojump_py"
    else:
        dic_file = config_dir+"/autojump_py"

    path_dict = open_dic(dic_file)

    if optlist.add:
        dicadd(path_dict, os.path.abspath(optlist.add))
        clean_dict(path_dict) #keep the database to a reasonable size
        save(path_dict, dic_file)

    elif optlist.remove:
        if dicremove(path_dict, optlist.remove):
            save(path_dict, dic_file)
        else:
            print("Key %s not found" % (optlist.remove), file=stderr)

    elif optlist.purge:
        limit = int(optlist.purge)
        if limit <= 0:
            print("Error : num must be positive", file=stderr)
            exit(-1)
        a = path_dict.items()
        for path,count in a:
            if count <= limit:
                dicremove(path_dict, path)
        save(path_dict, dic_file)
        stat()

    elif optlist.stat:
        stat()

    elif optlist.imp:
        if not os.path.exists(optlist.imp):
            print("Error database %s doesn't exists" % (optlist.imp), file=stderr)
            exit(-1)
        for i in open(optlist.imp).readlines():
            dicadd(path_dict, i[:-1])
        pickle.dump(path_dict, open(dic_file,'w'), -1)

    # Autojump search
    else:
        import re

        userchoice = -1 #i if the pattern is of the form __pattern__i, otherwise -1
        results = []
 
        if not args: patterns = [""]
        else: patterns = args

        #if the last pattern contains a full path, jump there
        #the regexp is because we need to support stuff like "j wo jo__3__/home/joel/workspace/joel" for zsh
        last_pattern_path = re.sub("(.*)" + completion_separator, "", patterns[-1])

        #print >> stderr, last_pattern_path
        if len(last_pattern_path) > 0 and last_pattern_path[0] == "/":
            if not optlist.completion: print(last_pattern_path)
        else:
            #check for ongoing completion, and act accordingly
            endmatch = re.search(completion_separator + "([0-9]+)", patterns[-1]) #user has selected a completion
            if endmatch:
                userchoice = int(endmatch.group(1))
                patterns[-1] = re.sub(completion_separator + "[0-9]+.*", "", patterns[-1])
            else: #user hasn't selected a completion, display the same choices again
                endmatch = re.match("(.*)" + completion_separator, patterns[-1])
                if endmatch: patterns[-1] = endmatch.group(1)

            dirs = list(path_dict.items())
            dirs.sort(key = itemgetter(1), reverse=True)

            if optlist.completion or userchoice != -1:
                max_matches = 9
            else:
                max_matches = 1

            try:
                cur_path = os.path.realpath(os.curdir)
            except OSError: #sometimes the current path doesn't exist anymore. In that case, jump if possible.
                cur_path = ''
                pass

            pattern=""
            for p in patterns[:-1]:
                pattern = "%s.*%s.*" % (pattern, p)
            
            pattern = "%s/[^/]*%s[^/]*$" % (pattern, patterns[-1])

            re_patterns = re.compile(pattern)
            find_matches(cur_path, dirs, pattern, results, False, max_matches)

            if not results or ((len(results) < max_matches) and optlist.completion): #if not found, try ignoring case. On completion always show all results
                find_matches(cur_path, dirs, pattern, results, True, max_matches)

            if optlist.completion and optlist.bash: quotes = '"'
            else: quotes = ""

            if userchoice != -1:
                if len(results) > userchoice-1 : print(quotes+results[userchoice-1]+quotes)
            elif len(results) > 1 and optlist.completion:
                print("\n" . join(("%s%s%d%s%s" % (patterns[-1], completion_separator, n+1, completion_separator, r)\
                                       for n,r in enumerate(results[:8]))))
            elif results: print(quotes + results[0] + quotes)
        exit(0)
    exit(1)
